import {
  Appear,
  Notes,
  Head,
} from 'mdx-deck'
import { Invert } from 'mdx-deck/layouts'
import future from '@mdx-deck/themes/future'
import highlight from '@mdx-deck/themes/syntax-highlighter-prism'

export const themes = [
  future,
  highlight
]

<Head>
  <title>Docker Field Guide Workshop</title>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css" rel="stylesheet" crossOrigin="anonymous" />
  <link href="https://afeld.github.io/emoji-css/emoji.css" rel="stylesheet" crossOrigin="anonymous" />
</Head>


<img width="500" src="https://github.com/Osones/formations/blob/master/images/docker-media-kit/large_v-trans.png?raw=true" alt="Moby Dock" className="inline-block" />

# Docker Workshop:

<h3 className="text-3xl italic text-gray-500">A Field Guide</h3>
<h5 className="text-sm mt-5 text-gray-600">Tom Gallacher, Ph.D</h5>

<a href="https://github.com/tgallacher/docker-field-guide-workshop/">
  <img src="./assets/github-light.png" className="inline-block mt-6" width="48" alt="view on github" />
</a>

---

# Goal

Provide context on the essentials of Docker to get started and be productive

---

# Agenda

- Docker fundamentals
- `Coffee`
- Dockerfile + services
- `Lunch`
- Multi-stage builds
- `Coffee`
- Dockerfile best practices

---

# Docker Fundamentals

---

import { Split } from 'mdx-deck/layouts'

# Why Docker?

<Split>

<img width="400" src="https://docs.docker.com/images/Container%402x.png" className="inline-block mr-4" />

<img width="400" src="https://docs.docker.com/images/VM%402x.png" className="inline-block" />

</Split>

- Lightweight
- Portable
- Scalable

<Notes>
  (1) containers run natively on Linux, sharing kernal; lower overhead
  (1) VMs full guest OS with virutal access to host resources through "hypervisor".
  (1) Flexible: Even the most complex applications can be containerized.
  (1) Lightweight: Containers leverage and share the host kernel.
  (1) Interchangeable: You can deploy updates and upgrades on-the-fly.
  (1) Portable: You can build locally, deploy to the cloud, and run anywhere.
  (1) Scalable: You can increase and automatically distribute container replicas.
  (1) Stackable: You can stack services vertically and on-the-fly.
</Notes>

---

# Terminology, terminology, terminology

- `docker` vs. `docker-engine` vs. `docker-machine` vs. `docker-compose`
- `image` vs. `container` vs. `swarms` vs. `stacks` vs. `services`
- `Dockerfile` vs `docker-compose.yml`

---

# First: Docker Architecture

---

# Client - Server

![](https://docs.docker.com/engine/images/engine-components-flow.png)

---

| | |
| --- | --- |
| `docker-compose` | client CLI for managing multi-docker container applications |
| `docker-machine` | remote management of distributed "`docker-daemon`"s |
| `docker` | docker "`client`" CLI |
| `docker api`    | interface between "`docker-daemon`" and "`docker`" client |
| `docker daemon` | the long runing "`docker-engine`" system process |
| `docker-engine` | brains which enables Docker's container runtime technology |

---

# Docker CLI

<h3 className="text-base mb-10 text-gray-700">(Time to get involved)</h3>

Getting started

---

# Is Docker installed?

```sh
docker --version
```

=> Docker version 18.09.2, build 6247962

---

# Hello world

---

# Hello world

```sh
docker run hello-world
```

---


<Invert>
  <h3>Example Output</h3>

  <img src="./assets/docker-hello-world-output.png" />
</Invert>

---

# Docker (CLI) Concepts

- `Stack`
- `Swarm`
- `Service`
- `Container`
- `Image`
- `Dockerfile`
- (`Volumes`)

---

| | |
| --- | --- |
| `Stack` | inter-related "`services`" running in concert |
| `Swarm` | collection of multiple "`Docker daemons`" joined within a single "`cluster`" |
| `Service` | configuration of a `container` which can also be scaled across multiple "`Docker daemons`" |
| `Container` | running instance of an "`image`" |
| `Image` | read-only snapshot for being able to run a process |
| `Dockerfile` | recipe guide for creating an "`image`" |
| `Volumes` | persistent storage |

---

# Docker (CLI) Concepts
We'll focus on:

- ~~`Stack`~~
- ~~`Swarm`~~
- ~~`Service`~~
- `Container`
- `Image`
- `Dockerfile`
- (`Volumes`)

<Notes>
  - Let's jumble the order a bit to make it easier.
</Notes>

---

# Our *first* app

<h3 className="text-gray-500 mb-10">"Talking whales"</h3>

1. Pull images from public registry
1. Run images as containers and execute their commands
1. Understand how to clean up

---

Pull the required image from public registry

```sh
docker pull docker/whalesay
```

---

Check the image is available on your machine

```sh
docker images
```

---

Run the image to get a container

(and provide the args to the default `CMD`)

```sh
docker run docker/whalesay 'docker rules!'
```

---

Is the container still running?

<Appear>
<p className="text-gray-600">How do we check?</p>
<p className="text-gray-600">How do we re-execute the command?</p>
</Appear>

---

```sh
docker container ls
```

---

View all containers (including those which are stopped)

```sh
docker container ls -a
```

---

# <i class="em em-koala"></i> Tip

Using `docker run` will auto `pull` images which it can't find locally

---

# Cleanup

1. Remove containers
1. Remove images

---

## Cleanup Containers

Get container ID

```sh
docker container ls
```

Remove

```
docker container rm <container_id>
```

---

# <i class="em em-koala"></i> Tip

Delete all (stopped) containers

```
docker container prune
```

See: https://docs.docker.com/engine/reference/commandline/container_prune/

---

# Cleanup Images

Get image ID

```sh
docker image ls
```

Remove

```
docker image rm <image_id>
```

---

# <i class="em em-koala"></i> Tip

Delete all unused images

```
docker image prune
```

See: https://docs.docker.com/engine/reference/commandline/image_prune/

---

# Recap

1. We've played around with some Docker resource concepts:
    - `image`, `container`
1. We've seem some of the Docker CLI commands:
    - `pull`, `run`, `container`, `image`
1. And we've done all this with some pre-built images from the **docker hub**

---

# How do we create our own images?

---

# Dockerfile

---

...

---


# Exercise...

2 basic exercies?

---

# Docker
Best practices

1. Single process per container
1. Keep images small
1. Use the right *base image*
1. Use multi-stage builds
1. Combine appropriate `RUN` directives
1. Combine shared components into a `base` image
1. Don't rely on `:latest` tag
1. Use `volumes` for storage

<Notes>
  - base image enables caching and better memory usage
  - Use `bind mounts` in development
</Notes>

---

# Ecercise

bind mount vols

---

`lunch`

---

# Dockerfile

Recipe guide for Docker images

---

# Dockerfile: FROM
# Dockerfile: RUN
# Dockerfile: COPY
# Dockerfile: EXPOSE
# Dockerfile: ENTRYPOINT
# Dockerfile: CMD

---

# Exercise

Build custom app with more than service

use docker-compose

---

# Multi-stage builds

FROM AS

COPY --from

---

# Exercise

Update above to use multi stage

---

#  Dockerfile

Best practices

---

1. Order directives from least to most likely to change,
    - e.g. `COPY` should come later
1. Increase specificity in `COPY` to avoid un-intentional cache bust,
    - e.g. don't use `COPY . `
1. Compress `RUN` pkg manager *update* and *install* into same line,
    - e.g. `RUN apt-get update && apt-get install`
1. Use official images where possible
    - reduces maintenance time, reduce size, configured for container use

<!-- /END -->
